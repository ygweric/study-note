import{_ as s,o,c as e,e as n}from"./app-CnK5B_QS.js";const a={},t=n(`<h1 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链"><span>原型链</span></a></h1><p>参考 <a href="https://segmentfault.com/a/1190000021232132" target="_blank" rel="noopener noreferrer">一张图搞定JS原型&amp;原型链</a></p><h2 id="函数、构造函数的区别" tabindex="-1"><a class="header-anchor" href="#函数、构造函数的区别"><span>函数、构造函数的区别</span></a></h2><p>任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#569CD6;">var</span><span style="color:#DCDCAA;"> Parent</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">function</span><span style="color:#D4D4D4;">(){}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955;">//定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通</span></span>
<span class="line"><span style="color:#569CD6;">var</span><span style="color:#9CDCFE;"> p1</span><span style="color:#D4D4D4;"> = </span><span style="color:#569CD6;">new</span><span style="color:#DCDCAA;"> Parent</span><span style="color:#D4D4D4;">();</span></span>
<span class="line"><span style="color:#6A9955;">//这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它</span></span>
<span class="line"><span style="color:#6A9955;">//创建了一个Parent构造函数的实例 p1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="proto-、prototype、-constructor" tabindex="-1"><a class="header-anchor" href="#proto-、prototype、-constructor"><span><code>__proto__</code>、prototype、 constructor</span></a></h2><ul><li><code>__proto__</code>、prototype、 constructor 是所有都有的，包括 函数、对象、数字、布尔</li><li>prototype 只有<strong>函数</strong>有，其他的是undefined</li><li><code>__proto__</code>属性相当于通往prototype唯一指针，因此任何东西都有<code>__proto__</code></li></ul><h2 id="实验" tabindex="-1"><a class="header-anchor" href="#实验"><span>实验</span></a></h2><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"></span>
<span class="line"><span style="color:#CE9178;">&#39;hello&#39;</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#6A9955;"> // </span></span>
<span class="line"><span style="color:#9CDCFE;">String</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#4EC9B0;">Function</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#6A9955;"> // </span></span>
<span class="line"><span style="color:#4EC9B0;">String</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#4EC9B0;">Object</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#6A9955;"> // </span></span>
<span class="line"><span style="color:#4EC9B0;">Object</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#569CD6;">null</span><span style="color:#6A9955;"> //  到头了，没了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对象的<code>__proto__</code>是父类的<code>prototype</code>（构造函数） 父类的<code>prototype</code>（构造函数）的<code>__proto__</code>是他的父类的<code>prototype</code></p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span style="color:#9CDCFE;">p1</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#4EC9B0;">Parent</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">; </span><span style="color:#6A9955;">// </span></span>
<span class="line"><span style="color:#4EC9B0;">Parent</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#4EC9B0;">Object</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">; </span><span style="color:#6A9955;">// x.__proto__ === Object.prototype， 因此万物基于 Object.prototype</span></span>
<span class="line"><span style="color:#4EC9B0;">Object</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">prototype</span><span style="color:#D4D4D4;">.</span><span style="color:#9CDCFE;">__proto__</span><span style="color:#D4D4D4;"> === </span><span style="color:#569CD6;">null</span><span style="color:#6A9955;"> // ， 因此Object.prototype就到头了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="constructor属性" tabindex="-1"><a class="header-anchor" href="#constructor属性"><span>constructor属性</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="background-color:#1E1E1E;color:#D4D4D4;"><pre class="shiki dark-plus vp-code"><code><span class="line"><span>String.constructor === Function</span></span>
<span class="line"><span>&#39;a&#39;.constructor === String</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,13),l=[t];function p(r,c){return o(),e("div",null,l)}const d=s(a,[["render",p],["__file","原型链.html.vue"]]),D=JSON.parse('{"path":"/interview/code/%E5%8E%9F%E5%9E%8B%E9%93%BE.html","title":"原型链","lang":"zh-CN","frontmatter":{"description":"原型链 参考 一张图搞定JS原型&原型链 函数、构造函数的区别 任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如： __proto__、prototype、 constructor __proto__、prototype、 constructor 是所有都有的，包括 函数、对象...","head":[["meta",{"property":"og:url","content":"https://cesium.guowei.fun/interview/code/%E5%8E%9F%E5%9E%8B%E9%93%BE.html"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:title","content":"原型链"}],["meta",{"property":"og:description","content":"原型链 参考 一张图搞定JS原型&原型链 函数、构造函数的区别 任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。如： __proto__、prototype、 constructor __proto__、prototype、 constructor 是所有都有的，包括 函数、对象..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-20T08:17:39.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-20T08:17:39.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"原型链\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-20T08:17:39.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"函数、构造函数的区别","slug":"函数、构造函数的区别","link":"#函数、构造函数的区别","children":[]},{"level":2,"title":"__proto__、prototype、 constructor","slug":"proto-、prototype、-constructor","link":"#proto-、prototype、-constructor","children":[]},{"level":2,"title":"实验","slug":"实验","link":"#实验","children":[]},{"level":2,"title":"constructor属性","slug":"constructor属性","link":"#constructor属性","children":[]}],"git":{"updatedTime":1732090659000,"contributors":[{"name":"国wei","email":"ygweric@gmail.com","commits":2}]},"autoDesc":true,"filePathRelative":"interview/code/原型链.md"}');export{d as comp,D as data};
