import{_ as o,o as n,c as a,e}from"./app-CnK5B_QS.js";const i={},d=e('<h1 id="qiankun-实现隔离原理" tabindex="-1"><a class="header-anchor" href="#qiankun-实现隔离原理"><span>qiankun 实现隔离原理</span></a></h1><p>在微前端架构中，<strong>应用隔离</strong>是核心需求之一，目的是避免不同微应用之间的 JS 变量污染和 CSS 样式冲突。qiankun（乾坤）作为主流的微前端框架，通过一套完善的机制实现了 JS 和 CSS 的隔离，下面分别解析其原理：</p><h3 id="一、js-隔离-基于沙箱-sandbox-机制" tabindex="-1"><a class="header-anchor" href="#一、js-隔离-基于沙箱-sandbox-机制"><span>一、JS 隔离：基于沙箱（Sandbox）机制</span></a></h3><p>qiankun 的 JS 隔离核心是<strong>沙箱</strong>，它能让每个微应用在独立的执行环境中运行，避免对全局 window 或其他应用造成污染。根据浏览器环境的不同，qiankun 提供了 3 种沙箱实现：</p><h4 id="_1-代理沙箱-proxysandbox-适用于支持-proxy-的现代浏览器" tabindex="-1"><a class="header-anchor" href="#_1-代理沙箱-proxysandbox-适用于支持-proxy-的现代浏览器"><span>1. 代理沙箱（ProxySandbox）：适用于支持 Proxy 的现代浏览器</span></a></h4><p>这是 qiankun 推荐的沙箱模式，性能最优，原理如下：</p><ul><li><strong>创建独立的代理对象</strong>：为每个微应用创建一个基于 <code>window</code> 的 Proxy 代理对象（<code>fakeWindow</code>），微应用的所有 JS 操作（如读写变量、添加事件监听等）都会通过这个代理对象进行。</li><li><strong>拦截全局访问</strong>： <ul><li>当微应用读取 <code>window.xxx</code> 时，代理会优先从 <code>fakeWindow</code> 中查找，若不存在则 fallback 到真实 <code>window</code>。</li><li>当微应用修改 <code>window.xxx</code> 时（如 <code>window.a = 1</code>），代理会将修改保存到 <code>fakeWindow</code> 中，而非直接修改真实 <code>window</code>，避免全局污染。</li><li>对于全局方法（如 <code>addEventListener</code>），代理会拦截并记录微应用添加的事件，在微应用卸载时自动清除，防止残留。</li></ul></li><li><strong>隔离性</strong>：每个微应用的 <code>fakeWindow</code> 相互独立，因此不同应用的变量修改不会互相影响。</li></ul><h4 id="_2-快照沙箱-snapshotsandbox-适用于不支持-proxy-的低版本浏览器-如-ie" tabindex="-1"><a class="header-anchor" href="#_2-快照沙箱-snapshotsandbox-适用于不支持-proxy-的低版本浏览器-如-ie"><span>2. 快照沙箱（SnapshotSandbox）：适用于不支持 Proxy 的低版本浏览器（如 IE）</span></a></h4><p>原理是通过<strong>快照备份与恢复</strong>实现隔离：</p><ul><li><strong>激活时（mount）</strong>： <ul><li>对当前全局 <code>window</code> 的状态（如变量、属性）进行快照（深拷贝关键属性），保存为 <code>windowSnapshot</code>。</li><li>将微应用上次运行时修改的状态（保存在 <code>modifiedMap</code> 中）恢复到 <code>window</code> 中。</li></ul></li><li><strong>失活时（unmount）</strong>： <ul><li>将当前 <code>window</code> 中被微应用修改的状态记录到 <code>modifiedMap</code>。</li><li>用之前的 <code>windowSnapshot</code> 覆盖当前 <code>window</code>，恢复到微应用激活前的状态。</li></ul></li><li>缺点：性能较差（频繁深拷贝），且只能支持单应用激活（多应用同时运行时快照会冲突）。</li></ul><h4 id="_3-legacy-沙箱-legacysandbox-兼容更早期的浏览器" tabindex="-1"><a class="header-anchor" href="#_3-legacy-沙箱-legacysandbox-兼容更早期的浏览器"><span>3. LEGACY 沙箱（LegacySandbox）：兼容更早期的浏览器</span></a></h4><p>与快照沙箱类似，但采用更简化的快照逻辑，仅记录微应用新增或修改的属性，而非全量快照，性能略优于快照沙箱，但隔离性稍弱。</p><h4 id="沙箱的工作流程" tabindex="-1"><a class="header-anchor" href="#沙箱的工作流程"><span>沙箱的工作流程</span></a></h4><ul><li><strong>激活（active）</strong>：微应用挂载时，启用对应的沙箱，将其 <code>fakeWindow</code> 或恢复的快照作为当前执行环境。</li><li><strong>失活（inactive）</strong>：微应用卸载时，沙箱暂停，恢复全局 <code>window</code> 到初始状态（或切换到其他应用的沙箱）。</li></ul><p>通过沙箱机制，qiankun 确保了每个微应用的 JS 执行环境相互隔离，避免了变量污染和残留。</p><h3 id="二、css-隔离-多种方案结合" tabindex="-1"><a class="header-anchor" href="#二、css-隔离-多种方案结合"><span>二、CSS 隔离：多种方案结合</span></a></h3><p>CSS 隔离的目标是防止不同微应用的样式互相干扰（如同名类选择器冲突）。qiankun 提供了 3 种主流的 CSS 隔离方案，可根据需求选择：</p><h4 id="_1-shadow-dom-隔离-推荐" tabindex="-1"><a class="header-anchor" href="#_1-shadow-dom-隔离-推荐"><span>1. Shadow DOM 隔离（推荐）</span></a></h4><p><strong>原理</strong>：利用浏览器原生的 Shadow DOM 特性，将微应用的 DOM 树挂载到一个 Shadow Root 中，实现样式的天然隔离。</p><ul><li><strong>Shadow DOM 的特性</strong>： <ul><li>内部样式不会泄露到外部（即微应用的样式只作用于 Shadow Root 内的 DOM）。</li><li>外部样式也无法穿透到 Shadow Root 内部（除非使用 <code>::part</code> 或 <code>::slotted</code> 等特殊选择器）。</li></ul></li><li><strong>qiankun 中的实现</strong>： <ul><li>当配置 <code>sandbox: { strictStyleIsolation: true }</code> 时，qiankun 会为微应用的容器创建 Shadow Root，并将微应用的 DOM 挂载到其中。</li><li>微应用加载的 CSS 会被自动注入到 Shadow Root 内，确保样式仅作用于自身。</li></ul></li><li>优点：隔离彻底，原生支持，无额外性能开销。</li><li>缺点：部分场景存在限制（如 Shadow DOM 内无法使用 <code>document.body</code> 等全局选择器，部分第三方组件可能不兼容）。</li></ul><h4 id="_2-css-前缀隔离-scoped-css" tabindex="-1"><a class="header-anchor" href="#_2-css-前缀隔离-scoped-css"><span>2. CSS 前缀隔离（Scoped CSS）</span></a></h4><p><strong>原理</strong>：通过为微应用的所有样式自动添加唯一前缀，确保其选择器仅匹配自身 DOM 元素。</p><ul><li><strong>实现步骤</strong>： <ul><li>qiankun 为每个微应用生成一个唯一标识（如 <code>__qiankun_microapp_wrapper_${appName}__</code>）。</li><li>微应用加载 CSS 时，qiankun 会通过 PostCSS 等工具遍历所有样式规则，为选择器添加前缀（如将 <code>.box</code> 转换为 <code>[data-qiankun=&quot;${appId}&quot;] .box</code>）。</li><li>同时，微应用的容器 DOM 会被添加该前缀属性（如 <code>&lt;div data-qiankun=&quot;app1&quot;&gt;...&lt;/div&gt;</code>），确保样式仅匹配容器内的元素。</li></ul></li><li>配置方式：<code>sandbox: { experimentalStyleIsolation: true }</code>。</li><li>优点：兼容性好，对第三方组件友好。</li><li>缺点：需要遍历和修改 CSS 规则，存在一定性能开销；若样式中存在全局选择器（如 <code>body</code>），可能需要额外处理。</li></ul><h4 id="_3-手动隔离-推荐结合使用" tabindex="-1"><a class="header-anchor" href="#_3-手动隔离-推荐结合使用"><span>3. 手动隔离（推荐结合使用）</span></a></h4><p>qiankun 也支持开发者通过手动约定实现 CSS 隔离，常见方案包括：</p><ul><li><strong>CSS Modules</strong>：通过工具将类名转换为唯一哈希值（如 <code>box</code> → <code>box_123</code>），避免冲突。</li><li><strong>BEM 命名规范</strong>：为每个微应用的样式添加统一前缀（如 <code>app1-button</code>、<code>app2-card</code>），通过命名空间隔离。</li><li><strong>CSS-in-JS</strong>：使用 styled-components 等工具，生成带唯一标识的样式类。</li></ul><h3 id="三、总结" tabindex="-1"><a class="header-anchor" href="#三、总结"><span>三、总结</span></a></h3><p>qiankun 的隔离机制通过“沙箱+样式隔离”双重保障，实现了微应用的独立运行：</p><ul><li><strong>JS 隔离</strong>：通过 Proxy 代理或快照备份，确保每个应用的全局变量和方法互不干扰。</li><li><strong>CSS 隔离</strong>：通过 Shadow DOM 原生隔离或 CSS 前缀转换，避免样式冲突。</li></ul><p>这些机制使得多个技术栈不同、开发团队独立的应用能够无缝集成到同一页面，是微前端架构落地的核心保障。</p><h3 id="_1-关于-shadow-dom-在-qiankun-中的使用" tabindex="-1"><a class="header-anchor" href="#_1-关于-shadow-dom-在-qiankun-中的使用"><span>1. 关于 Shadow DOM 在 qiankun 中的使用</span></a></h3><p>qiankun 提供了多种样式隔离方案，其中一种就是通过 Shadow DOM 实现：</p><ul><li>当配置 <code>sandbox: { strictStyleIsolation: true }</code> 时，qiankun 会为子应用的容器创建 Shadow DOM，将子应用的 DOM 树挂载到 Shadow Root 中。</li><li>此时子应用的样式会被 Shadow DOM 隔离，不会影响主应用或其他子应用（类似 scoped CSS 的效果，但隔离级别更高）。</li></ul><p>但需要注意：</p><ul><li>Shadow DOM 是<strong>可选功能</strong>，默认不启用（qiankun 默认使用较为轻量的 <code>experimentalStyleIsolation</code> 方案，通过 CSS 前缀隔离样式）。</li><li>Shadow DOM 仅解决<strong>样式隔离和 DOM 树隔离</strong>，不涉及 JavaScript 执行环境的隔离。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>qiankun <strong>支持使用 Shadow DOM</strong>，但主要用于样式隔离，且为可选配置。</li><li>Shadow DOM <strong>不直接具备 JavaScript 沙箱功能</strong>，qiankun 的 JS 沙箱通过 Proxy 代理机制独立实现，与 Shadow DOM 无关。</li><li>实际使用中，可根据需求单独或同时启用样式隔离（如 Shadow DOM）和 JS 沙箱。</li></ul>',37),t=[d];function l(s,c){return n(),a("div",null,t)}const p=o(i,[["render",l],["__file","qiankun 实现隔离原理.html.vue"]]),h=JSON.parse('{"path":"/fe/micro-fe/qiankun/qiankun%20%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E5%8E%9F%E7%90%86.html","title":"qiankun 实现隔离原理","lang":"zh-CN","frontmatter":{"description":"qiankun 实现隔离原理 在微前端架构中，应用隔离是核心需求之一，目的是避免不同微应用之间的 JS 变量污染和 CSS 样式冲突。qiankun（乾坤）作为主流的微前端框架，通过一套完善的机制实现了 JS 和 CSS 的隔离，下面分别解析其原理： 一、JS 隔离：基于沙箱（Sandbox）机制 qiankun 的 JS 隔离核心是沙箱，它能让每个微...","head":[["meta",{"property":"og:url","content":"https://cesium.guowei.fun/fe/micro-fe/qiankun/qiankun%20%E5%AE%9E%E7%8E%B0%E9%9A%94%E7%A6%BB%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:title","content":"qiankun 实现隔离原理"}],["meta",{"property":"og:description","content":"qiankun 实现隔离原理 在微前端架构中，应用隔离是核心需求之一，目的是避免不同微应用之间的 JS 变量污染和 CSS 样式冲突。qiankun（乾坤）作为主流的微前端框架，通过一套完善的机制实现了 JS 和 CSS 的隔离，下面分别解析其原理： 一、JS 隔离：基于沙箱（Sandbox）机制 qiankun 的 JS 隔离核心是沙箱，它能让每个微..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-06T08:29:49.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-06T08:29:49.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"qiankun 实现隔离原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-06T08:29:49.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":3,"title":"一、JS 隔离：基于沙箱（Sandbox）机制","slug":"一、js-隔离-基于沙箱-sandbox-机制","link":"#一、js-隔离-基于沙箱-sandbox-机制","children":[]},{"level":3,"title":"二、CSS 隔离：多种方案结合","slug":"二、css-隔离-多种方案结合","link":"#二、css-隔离-多种方案结合","children":[]},{"level":3,"title":"三、总结","slug":"三、总结","link":"#三、总结","children":[]},{"level":3,"title":"1. 关于 Shadow DOM 在 qiankun 中的使用","slug":"_1-关于-shadow-dom-在-qiankun-中的使用","link":"#_1-关于-shadow-dom-在-qiankun-中的使用","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1754468989000,"contributors":[{"name":"国wei","email":"ygweric@gmail.com","commits":1}]},"autoDesc":true,"filePathRelative":"fe/micro-fe/qiankun/qiankun 实现隔离原理.md"}');export{p as comp,h as data};
